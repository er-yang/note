# 事件循环

事件循环本质是node或浏览器运行js 时处理非阻塞I/O操作的机制，负责执行代码、收集和处理事件以及执行队列中的子任务。

之所以称之为 **事件循环**，是因为它经常按照类似如下的方式来被实现：

```
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
```

`queue.waitForMessage()` 会同步地等待消息到达(如果当前没有任何消息等待被处理)。



### 浏览器事件循环

浏览器下任务会被分成micro task微任务和macro task宏任务，在主线程执行完当前任务时，会先去检测微任务队列是否存在待执行任务，如果不存在会去宏任务队列中取出前面的第一个事件（如果有的话）执行，微任务队列中如果存在待执行任务，会先执行完微任务队列中的所有事件，在去宏任务队列中取出前面的第一个事件执行，如此循环。

### node事件循环

当 Node.js 启动后，它会初始化事件循环，处理已提供的输入脚本，它可能会调用一些异步的 API、调度定时器，或者调用 `process.nextTick()`，然后开始处理事件循环

```
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```

* timer 定时器：本阶段执行setTimeout和setInterval的调度回调函数
* pending callbacks待定回调：执行延迟到下一个循环迭代的 I/O 回调
* idle, prepare：仅系统内部使用
* poll **轮询**：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 `setImmediate()` 调度的之外），其余情况 node 将在适当的时候在此阻塞。
* check：`setImmediate()` 回调函数在这里执行
* close callbacks关闭的回调函数：一些关闭的回调函数，如：`socket.on('close', ...)`。

##### 定时器

***注意**：**轮询** 阶段控制何时定时器执行

##### 待定回调挂起的回调函数

此阶段对某些系统操作（如 TCP 错误类型）执行回调。例如，如果 TCP 套接字在尝试连接时接收到 `ECONNREFUSED`，则某些 *nix 的系统希望等待报告错误。这将被排队以在 **挂起的回调** 阶段执行。

##### 轮询

轮询 阶段有两个重要的功能：

1. 计算应该阻塞和轮询 I/O 的时间。
2. 然后，处理 **轮询** 队列里的事件。

当事件循环进入轮询阶段，*如果 **轮询** 队列 **不是空的*** ，事件循环将循环访问回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬性限制，当队列为空时如果有setImmediate调度，则进行检查阶段，当没有且同时也没timer调度，则事件循环将等待回调被添加到队列中，然后立即执行。

#####  关闭的回调函数

如果套接字或处理函数突然关闭（例如 `socket.destroy()`），则`'close'` 事件将在这个阶段发出。否则它将通过 `process.nextTick()` 发出。

#### process.nextTick()

您可能已经注意到 `process.nextTick()` 在图示中没有显示，即使它是异步 API 的一部分。这是因为 `process.nextTick()` 从技术上讲不是事件循环的一部分。相反，它都将在当前操作完成后处理 `nextTickQueue`， 而不管事件循环的当前阶段如何。这里的一个**操作被视作为一个从底层 C/C++ 处理器开始过渡，并且处理需要执行的 JavaScript 代码**。

##### promise微任务

在node中promise的微任务队列在nextTick队列后执行，当事件循环执行完nextTick队列，后会检查并执行完微任务队列。

![node_micro](/Users/yangyuancai/Desktop/priwork/note/source/node_micro_task.jpg)

#### 为什么要使用 `process.nextTick()`?

 有两个主要原因：

1. 允许用户处理错误，清理任何不需要的资源，或者在事件循环继续之前重试请求。
2. 有时有让回调在栈展开后，但在事件循环继续之前运行的必要。